/***************************************
Author: 			 			Lior Bondorevsky
Creation date: 			19/11/2014
Last modofied date: 4/12/2014
Description: 				TCP clients loop
***************************************/
#include <string.h> /* strlen */
#include <stdlib.h> /* system */
#include <stdio.h>  /* perror */
#include <errno.h>  /* errno */
#include <unistd.h> /* close, sleep */
#include <sys/socket.h> /* socket */
#include <netinet/in.h> /* sockaddr_in */
#include <arpa/inet.h>  /* inet_pton */

#include "fileserver_protocol.h"

#define SYS_ERROR  -1
#define OK          0
#define TRUE        1
#define SERVER_PORT 5060
#define BUFFER_SIZE 80

#define CONNECT_PERCENTAGE 1 /* 1/3 = 33%  XXX now one single_client */
#define SEND_PERCENTAGE    1 /* 1/2 = 50% XXX now one single_client  */

#define DATA_SIZE      64
#define BUFFER_SIZE    64000
#define SLEEP_TIME     10000 /* in usec */
#define CLIENTS_NUM    1 /* XXX now one single_client  */

#define ILYA_IP        "192.168.1.105"
#define EYAL_IP        "192.168.1.72"
#define BENNY_IP       "192.168.1.59"
#define MY_IP          "192.168.1.68"
#define LOOPBACK_IP    "127.0.0.1"


#define SERVER_IP       LOOPBACK_IP 
#define CLIENT_FILENAME "/home/lior/test/client.tar.gz"
#define CHKSUM_FILENAME "/home/lior/test/md5_chk_sum_client"


static void SetMD5ChkSum(FileServerHeader* _fsh)
{
  FILE* chkSumFile = NULL;
  
  assert(_fsh);
  
  system("md5sum " CLIENT_FILENAME " > " CHKSUM_FILENAME);
  
  /* Open checksum file */
  chkSumFile = fopen(CHKSUM_FILENAME, "r");
  if(!chkSumFile)
  {
    perror("fopen");
  }
  fread(_fsh->m_checkSum, sizeof(char), CHK_SUM_SIZE - 1, chkSumFile);
  if(ferror(chkSumFile))
  {
    perror("fread");
  }
  _fsh->m_checkSum[CHK_SUM_SIZE-1] = '\0';
  
  /* Close server file */
  if(fclose(chkSumFile))
  {
  	perror("fclose");
  }
  
  system("rm " CHKSUM_FILENAME); 
}

int main()
{
  int clientSocket[CLIENTS_NUM];
  int byteWrite;
  int totBytesRead = 0;
  int currBytesRead;
  int clientIndex;
  int isFileSent = FALSE;
  int chunkCounter = 0;
  
  struct rlimit rl;
  
  struct sockaddr_in serverAddr;
  
  char   data[DATA_SIZE];
  size_t dataLen;
  char   buffer[BUFFER_SIZE];
  
  FILE* pFile = NULL;
  size_t fileSize;
  
  FileServerHeader fsHeader;
  char clientChkSum[CHK_SUM_SIZE];
  
  /* Open server file */
  pFile = fopen(CLIENT_FILENAME, "wb");
	if(!pFile)
	{
		perror("fopen");
    return errno;
	}
  
  /* Init serverAddr */
  memset(&serverAddr, 0, sizeof(serverAddr));
  serverAddr.sin_family = AF_INET;
  serverAddr.sin_port   = htons(SERVER_PORT);
  inet_pton(AF_INET, SERVER_IP, &serverAddr.sin_addr); 
  
  /* Init random seed */
  srand(time(NULL));
  
  /* Set open files limit */
  rl.rlim_cur = CLIENTS_NUM + 10;
  rl.rlim_max = CLIENTS_NUM + 10;

  if(SYS_ERR == setrlimit(RLIMIT_NOFILE, &rl))
  {
    perror("setrlimit");
    return errno;
  }
 
  /* Clients connection & request loop */
  for(clientIndex = 0; clientIndex < CLIENTS_NUM; ++clientIndex)
  { 
    /* Init client socket */
    clientSocket[clientIndex] = socket(AF_INET, SOCK_STREAM, 0);
    if(SYS_ERR == clientSocket[clientIndex])
    {
      perror("socket");
      return errno;
    }
    
    /* Connect to server --> only CONNECT_PERCENTAGE of the clients */
    if(!(rand() % CONNECT_PERCENTAGE))
    {
      if(SYS_ERR == connect(clientSocket[clientIndex], (const struct sockaddr*)&serverAddr, sizeof(serverAddr)))
      {
        perror("connect");
        return errno;
      }
      
      /* send to server --> only SEND_PERCENTAGE of the clients */
      if(!(rand() % SEND_PERCENTAGE))
      {
        /* Write message */
        sprintf(data, "hello server! its client #%d", clientIndex + 1);
        dataLen = strlen(data) + 1;
        byteWrite = write(clientSocket[clientIndex], data, dataLen);
        
        if(SYS_ERR == byteWrite || byteWrite != dataLen)
        {
          perror("write");
          return errno;
        }
       
        printf("\nclient sent: %s\n", data);
            
        /* Recieve Header */
        if(SYS_ERR == read(clientSocket[clientIndex], &fsHeader, sizeof(fsHeader)))    
        {
          perror("read");
          return errno;
        }
        
        fileSize = fsHeader.m_size; 
        strcpy(clientChkSum, fsHeader.m_checkSum);
        printf("client recieved header\n");
        
      }
      /* delay */
      usleep(SLEEP_TIME);
    }
  } /* for(...) */
  
  
  while(!isFileSent)
  {
    /* Recieve file chunk */
    currBytesRead = read(clientSocket[0], buffer, sizeof(buffer));
    if(SYS_ERR == currBytesRead)    
    {
      perror("read");
      return errno;
    }
    if(currBytesRead == 0)
    {
      break;
    }
    printf("client recieved file chunk #%d\n", ++chunkCounter);
    
    fwrite(buffer, sizeof(char), currBytesRead, pFile);
    
    totBytesRead += currBytesRead;
    
    if(totBytesRead == fileSize)
    {
      isFileSent = TRUE;
    }
  }
  
  /* Close all client sockets */
  for(clientIndex = 0; clientIndex < CLIENTS_NUM; ++clientIndex)
  {
    if(SYS_ERR == close(clientSocket[clientIndex]))
    {
      perror("close");
    }
  }
  
  /* Close file */
  if(fclose(pFile))
  {
  	perror("fclose");
    return errno;
  }
  
  
  SetMD5ChkSum(&fsHeader);
      
  if(strcmp(clientChkSum, fsHeader.m_checkSum) == 0)
  {
    printf("\nFile MD5 Checksum OK :)\n\n");
  }
  else
  {
    fprintf(stderr, "\nFile MD5 Checksum Failed!\n\n");
  }
  
  
	return OK;
}
