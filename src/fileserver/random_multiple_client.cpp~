/*******************************************
Author: 			 			Lior Bondorevsky
Creation date: 			17/12/2014
Last modofied date: 17/12/2014
Description: 				FileServer single client
*******************************************/
#include <string.h> // strlen 
#include <stdlib.h> // system 
#include <stdio.h>  // perror 
#include <errno.h>  // errno 
#include <cassert>  // assert 
#include <time.h>   // time 
#include <unistd.h> // close, sleep 
#include <sys/socket.h> // socket 
#include <netinet/in.h> // sockaddr_in 
#include <arpa/inet.h>  // inet_pton 
#include <sys/resource.h> // setrlimit 
#include <iostream>       // cout, endl
#include <string>         // string

#include "fileserver_protocolos.h"

using namespace adv_cpp;
using std::cout;
using std::cin;
using std::cerr;
using std::endl;
using std::string;


#define SYS_ERR    -1
#define OK          0
#define FALSE       0
#define TRUE        1
#define SERVER_PORT 5061

#define CONNECT_PERCENTAGE 1 // 1/3 = 33%  XXX now single_client 
#define SEND_PERCENTAGE    1 // 1/2 = 50% XXX now single_client  

#define SLEEP_TIME     10000 // in usec (between clients)
#define CLIENTS_NUM    1 // XXX one single_client  

#define ILYA_IP        "192.168.1.105"
#define EYAL_IP        "192.168.1.72"
#define BENNY_IP       "192.168.1.59"
#define MY_IP          "192.168.1.68"
#define LOOPBACK_IP    "127.0.0.1"


#define SERVER_IP       LOOPBACK_IP 

static const char* CLIENT_FILENAME = "/home/lior/test/client/client.tar.gz"; //discovery_file";

int main()
{
  int clientSocket[CLIENTS_NUM];
  
  struct rlimit rl;
  
  struct sockaddr_in serverAddr;

  // Init serverAddr 
  memset(&serverAddr, 0, sizeof(serverAddr));
  serverAddr.sin_family = AF_INET;
  serverAddr.sin_port   = htons(SERVER_PORT);
  inet_pton(AF_INET, SERVER_IP, &serverAddr.sin_addr); 
  
  // Init random seed 
  srand(time(NULL));
  
  // Set open files limit 
  rl.rlim_cur = CLIENTS_NUM + 10;
  rl.rlim_max = CLIENTS_NUM + 10;

  if(SYS_ERR == setrlimit(RLIMIT_NOFILE, &rl))
  {
    perror("setrlimit");
    return errno;
  }

  // Clients connection & request loop 
  for(int clientIndex = 0; clientIndex < CLIENTS_NUM; ++clientIndex)
  { 
    // Init client socket 
    clientSocket[clientIndex] = socket(AF_INET, SOCK_STREAM, 0);
    if(SYS_ERR == clientSocket[clientIndex])
    {
      perror("socket");
      return errno;
    }
    
    // Connect to server --> only CONNECT_PERCENTAGE of the clients 
    if(!(rand() % CONNECT_PERCENTAGE))
    {
      if(SYS_ERR == connect(clientSocket[clientIndex], (const struct sockaddr*)&serverAddr, sizeof(serverAddr)))
      {
        perror("connect");
        return errno;
      }
      
      // send to server --> only SEND_PERCENTAGE of the clients 
      if(!(rand() % SEND_PERCENTAGE))
      {
        RepoProtocol repo(clientSocket[clientIndex], clientIndex + 1);
        
        // DISCOVERY PART
        cout << endl << "client send DISCOVERY" << endl;
        if(!repo.Discovery(CLIENT_FILENAME))
        {
          cerr << endl << "Discovery Failed!" << endl << endl;
          continue;
        }
        cout << endl << "Repository Files List: Transfer & MD5 Checksum OK :)" << endl << endl;
               
        // GET_SERV_FOR_GET PART
        string chosenFilename;
        cout << "specify filename from recieved repository files list: ";
        cin >> chosenFilename;
      }
      // delay 
      usleep(SLEEP_TIME);
    }
  } // for(...) 
  
  
  // Close all client sockets 
  for(int clientIndex = 0; clientIndex < CLIENTS_NUM; ++clientIndex)
  {
    if(SYS_ERR == close(clientSocket[clientIndex]))
    {
      perror("close");
    }
  }
  
	return OK;
}
