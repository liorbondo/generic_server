/********************************************************
Author: 			 			Lior Bondorevsky
Creation date: 			17/12/2014
Last modofied date: 20/12/2014
Description: 				FileServer Protocols implementation 
********************************************************/
#include <cstdio>   // sprintf, fwrite
#include <unistd.h> // read, write
#include <cstring>  // memset
#include <cassert>  // assert
#include <string>   // string
#include <cstdlib>  // system
#include <sys/socket.h> // socket 
#include <netinet/in.h> // sockaddr_in 
#include <arpa/inet.h>  // inet_pton 
#include <stdexcept>    // std::runtime_error

#include "fileserver_protocolos.h" // Class Headers
#include "fileserver_common.h"     // FileServerHeader, MD5ChkSum, IpPort

#define SYS_ERR -1

namespace adv_cpp
{

// XXX FileServerProtocol Implementation XXX

FileServerProtocol::FileServerProtocol(const char* _ip, short _port, int _id)
: m_fd(-1),
  m_id(_id),
  m_recvHeader(new FileServerHeader) 
{
  memset(m_recvHeader, 0, sizeof(FileServerHeader));
  
  // Init serverAddr 
  struct sockaddr_in serverAddr;
  memset(&serverAddr, 0, sizeof(serverAddr));
  serverAddr.sin_family = AF_INET;
  serverAddr.sin_port   = htons(_port);
  inet_pton(AF_INET, _ip, &serverAddr.sin_addr); 

  // Init client socket 
  m_fd = socket(AF_INET, SOCK_STREAM, 0);
  if(SYS_ERR == m_fd)
  {
    perror("socket");
    throw std::runtime_error("socket failed");
  }
    
  // Connect to server 
  if(SYS_ERR == connect(m_fd, (const struct sockaddr*)&serverAddr, sizeof(serverAddr)))
  {
    perror("connect");
    throw std::runtime_error("connect failed");
  }
}
  
  
FileServerProtocol::~FileServerProtocol()
{
  // Close client socket
  if(SYS_ERR == close(m_fd))
  {
    perror("close");
  }
  
  if(m_recvHeader)
  {
    delete m_recvHeader;
  }
  
  m_recvHeader = NULL;
}  


bool FileServerProtocol::WriteSocketToFile(const char* _fileName)
{
  assert(_fileName);
  
  static const size_t BUFFER_SIZE = 65536;
  char buffer[BUFFER_SIZE] = {0};
  ssize_t totBytesWritten = 0;
  
  // Open filesList file 
  FILE* pFile = fopen(_fileName, "wb");
	if(!pFile)
	{
		perror("fopen");
    return false;
	}
  
  // Breaks when fileSent or on read error
  while(true)
  {
    // Recieve file chunk 
    int currBytesRead = read(m_fd, buffer, sizeof(buffer));
    if(SYS_ERR == currBytesRead)    
    {
      perror("read");
      return false;
    }
    if(currBytesRead == 0)
    {
      fprintf(stderr, "\nerror: connection closed\n\n");
      return false;
    }
    
    int currBytesWritten = fwrite(buffer, sizeof(char), currBytesRead, pFile);
    if(SYS_ERR == currBytesWritten)    
    {
      perror("write");
      return false;
    }
    if(currBytesWritten == 0)
    {
      fprintf(stderr, "\nerror: connection closed\n\n");
      return false;
    }
    
    totBytesWritten += currBytesWritten; 
    if(totBytesWritten == m_recvHeader->m_size)
    {
      break;
    }
  }
  
  // Close file 
  if(fclose(pFile))
  {
  	perror("fclose");
    return false;
  }
  
  if(MD5ChkSum(_fileName) != m_recvHeader->m_checkSum)
  {
    fprintf(stderr, "\nFile MD5 Checksum Failed!\n\n");
    return false;
  }
  
  return true;
}


// XXX RepoProtocol Implementation XXX


RepoProtocol::RepoProtocol(const char* _ip, short _port, int _id)
: FileServerProtocol(_ip, _port, _id) {} 


namespace Details
{

bool SendMsg(int _fd, int _id, const char* _type, const char* _fileName)
{
  assert(_type);
  
  char data[32];
  
  // Prepare message by type 
  if(strcmp(_type, "DISC") == 0)
  {
    // _fileName not in use in DISC
    sprintf(data, "%s#%d", _type, _id);
  }  
  else if(strcmp(_type, "GSFG") == 0)
  {
    // _id not in use in GSFG
    // TODO hash filename
    sprintf(data, "%s#%s", _type, _fileName);
  } 
  else
  {
    fprintf(stderr, "\nUnknown message\n\n");
    return false;
  }
  
  // Send the message
  int dataLen = strlen(data) + 1;
  int bytesWritten = write(_fd, data, dataLen);
  if(SYS_ERR == bytesWritten || bytesWritten != dataLen)
  {
    perror("write");
    return false;
  }
  
  return true;
}

} // namespace Details


bool RepoProtocol::Discovery(const char* _fileName)
{
  assert(_fileName);
  
  // Write DISCOVERY message 
  if(!Details::SendMsg(m_fd, m_id, "DISC", NULL))
  {
    fprintf(stderr, "\nSendMsg failed\n\n");
    return false;
  }
  
  // Recieve Header 
  if(SYS_ERR == read(m_fd, m_recvHeader, sizeof(FileServerHeader)))    
  {
    perror("read");
    return false;
  }
  
  if(SYS_ERR == m_recvHeader->m_size)
  {
    fprintf(stderr, "\ninvalid file error\n\n");
    return false;
  }
  
  return WriteSocketToFile(_fileName);
}


bool RepoProtocol::GetServersForGet(const char* _fileName, IpPort* _ipp1, IpPort* _ipp2)
{
  assert(_fileName);
  assert(_ipp1);
  assert(_ipp2);
  
  // Write GET_SERV_FOR_GET message 
  if(!Details::SendMsg(m_fd, m_id, "GSFG", _fileName))
  {
    fprintf(stderr, "\nSendMsg failed\n\n");
    return false;
  }
  
  // FIXME part below should be replaced with real IP:PORT
  strcpy(_ipp1->m_ip, "127.1.1.1");
  _ipp1->m_port = 1061;
  
  strcpy(_ipp2->m_ip, "127.2.2.2");
  _ipp2->m_port = 2062;
  
  return true;
}

} // namespace adv_cpp


