/******************************************************
Author:             Lior Bondorevsky
Creation date:      17/12/2014
Last modofied date: 20/12/2014
Description:        FsRepo Handler Implementation
*******************************************************/
#include <errno.h>  // errno
#include <iostream> // cerr
#include <unistd.h> // read
#include <cstring>  // memchr
#include <cstdlib>  // atoi
#include <cassert>  // assert
#include <cstdio>   // sprintf
#include <signal.h> // SIGINT

#include "repo_handler.h"
#include "reactor_mask.h"      // Mask
#include "fileserver_common.h" // MD5ChkSum, FileServerHeader

#define SYS_ERR            -1
#define OK                  0

namespace adv_cpp
{

// CLASS DEFINES
const char* FsRepoHandler::FILES_LIST_PATH    = "/home/lior/test/server/repo_files"; // file.tar.gz"; 
const int   FsRepoHandler::EOF_STATUS         = 2;
const int   FsRepoHandler::CONN_CLOSED_STATUS = 3;

FsRepoHandler::FsRepoHandler() 
: m_id(-1),
  m_filesList(NULL),
  m_fileOffset(0),
  m_bufferOffset(0),
  m_currReadSize(0),
  m_isEof(false) {}


FsRepoHandler::~FsRepoHandler() {}


int FsRepoHandler::Open()
{
  if(SYS_ERR == this->GetReactor()->RegisterIO(this, READ))
  {
    std::cerr << "RegisterIO failed" << std::endl;
    return SYS_ERR;
  }
  
  if(SYS_ERR == this->GetReactor()->RegisterSignal(this, SIGINT))
  {
    std::cerr << "RegisterSignal failed" << std::endl;
    return SYS_ERR;
  }

  // Open server filesList file 
	m_filesList = fopen(FILES_LIST_PATH, "rb");
	if(!m_filesList)
	{
		perror("fopen");
    return SYS_ERR;
	}

  return OK;
}


int FsRepoHandler::HandleSignal(int _signal)
{
  switch(_signal)
  {
    case SIGINT:
      if(SYS_ERR == this->HandleClose(this->GetFd()))
      {
       std::cerr << "HandleClose failed" << std::endl;
       return SYS_ERR;
      } 
    break; 
  }
  
  return OK;
}


int FsRepoHandler::HandleTimer(void* _arg)
{
  std::cout << "client #" << m_id << " timeout elapsed" << std::endl; 
  
  if(SYS_ERR == this->HandleClose(this->GetFd()))
  {
    std::cerr << "HandleClose failed" << std::endl;
    return SYS_ERR;
  }
  
  return OK;
}


namespace Details
{

enum MsgTypes
{
  UNKNOWN = 0,
  DISCOVERY,
  GET_SERV_FOR_GET
};

static MsgTypes ParseMsg(const char* _msg)
{
  std::string msg(_msg);
  
  // keep the msg type prefix
  msg.erase(msg.find('#'));
  
  if(msg == "DISC")
  {
    return DISCOVERY;
  }
  if(msg == "GSFG")
  {
    return GET_SERV_FOR_GET;
  }
    
  return UNKNOWN;  
} 

static ssize_t FileSize(FILE* _fp)
{
	ssize_t result;
	
	assert(_fp);
	
	if(fseek(_fp, 0, SEEK_END))
	{
    perror("fseek");
    return SYS_ERR;
  } 
  
	result = ftell(_fp);
	if(SYS_ERR == result)
	{
    perror("ftell");
    return SYS_ERR;
  } 
	
	if(fseek(_fp, 0, SEEK_SET))
	{
    perror("fseek");
    return SYS_ERR;
  } 
	
	return result;
}

} // namespace Details


inline int FsRepoHandler::SendHeader()
{
  FileServerHeader fileHeader; 
  memset(&fileHeader, 0, sizeof(fileHeader));
  
  // Init Header message: FileSize & MD5 checksum
  fileHeader.m_size = Details::FileSize(m_filesList);
  strcpy(fileHeader.m_checkSum, MD5ChkSum(FILES_LIST_PATH).c_str());

  // Send response
  int bytesWritten = write(GetFd(), &fileHeader, sizeof(fileHeader));
  if(SYS_ERR == bytesWritten || bytesWritten != sizeof(fileHeader))
  {
    perror("write");
    return SYS_ERR;
  }
  
  return OK;
}


inline int FsRepoHandler::HandleDiscovery()
{
  // Client id sent with Discovery
  m_id = atoi((char*)(memchr(m_buffer, '#', BUFFER_SIZE)) + 1);
  
  if(SYS_ERR == SendHeader())
  {
    return SYS_ERR;
  }
  std::cout << "repository server sent header" << std::endl;
  
  // Fill the client write buffer
  std::cout << "repository server sending files list" << std::endl;
  int status = HandleOutput(GetFd());
  if(EOF_STATUS != status && SYS_ERR == this->GetReactor()->RegisterIO(this, WRITE))
  {
    std::cerr << "RegisterIO failed" << std::endl;
    return SYS_ERR;
  }  
  
  return OK;
}


inline int FsRepoHandler::HandleGSFG()
{
  std::string msg(m_buffer);
  
  // keep the msg filename suffix
  msg.erase(0, msg.find('#') + 1);
  
  std::cerr << "not implemented yet! buf file is: " << msg << std::endl;
  // TODO write PORT:IP pair to client after using hased filename to get this from table
  
  return OK;
}


inline int FsRepoHandler::ReadSocketToBuffer()
{
  int fd = GetFd();
  int readBytes = read(fd, m_buffer, sizeof(m_buffer));
        
  // Client has closed connection or real error occured (not including non readable socket) TODO make inline function
  if((SYS_ERR == readBytes && EAGAIN != errno && EWOULDBLOCK != errno) || 0 == readBytes)
  {
    std::cout << "client #" << m_id << " closed connection" << std::endl;
    
    if(SYS_ERR == this->HandleClose(fd))
    {
      std::cerr << "HandleClose failed" << std::endl;
    }    
    
    return SYS_ERR;
  }
  
  return OK;
}


int FsRepoHandler::HandleInput(int _fd)
{
  if(SYS_ERR == ReadSocketToBuffer())
  {
    return SYS_ERR;
  }
  
  // Read Succeeded. Parsing incoming msg and handling by type
  std::cout << "repository server recieved: " << m_buffer << std::endl;

  switch(Details::ParseMsg(m_buffer))
  {
    case Details::DISCOVERY:
      return HandleDiscovery();
      
    case Details::GET_SERV_FOR_GET:
      return HandleGSFG();
   
    case Details::UNKNOWN:
      std::cerr << "unknown msg recieved" << std::endl;
    return SYS_ERR;  
  }
  
  return OK;
}


int FsRepoHandler::HandleOutput(int _fd)
{
  // XXX currently output is only file list sending for DISCOVERY
  // Send file to client socket 
  int status = WriteFileToSocket();
  if(EOF_STATUS == status)
  {
    // File send complete 
    std::cout << "file send complete" << std::endl;
    // UnRegister from Reactor Write set
    if(SYS_ERR == this->GetReactor()->UnRegisterIO(this, WRITE))
    {
      std::cerr << "UnRegisterIO failed" << std::endl;
      return SYS_ERR;
    }
    
    return EOF_STATUS;
  } 
  else if(CONN_CLOSED_STATUS == status)
  {
    std::cout << "client #" << m_id << " closed connection" << std::endl;

    if(SYS_ERR == this->HandleClose(GetFd()))
    {
      std::cerr << "HandleClose failed" << std::endl;
    }   
  }  
  else if(SYS_ERR == status)
  {
    std::cerr << "WriteFileToSocket Failed" << std::endl;
  }
  
  return OK;
}


int FsRepoHandler::HandleClose(int fd)
{
  // Close filesList
  if(fclose(m_filesList))
  {
    perror("fclose");
    return SYS_ERR;
  }

  // UnRegister from Signaling
  if(SYS_ERR == this->GetReactor()->UnRegisterSignal(this, SIGINT))
  {
    std::cerr << "RegisterSignal failed" << std::endl;
    return SYS_ERR;
  }
    
  // UnRegister from Reactor Read set
  if(SYS_ERR == this->GetReactor()->UnRegisterIO(this, READ))
  {
    std::cerr << "UnRegisterIO failed" << std::endl;
    return SYS_ERR;
  }
  
  // UnRegister from Reactor Write set
  if(SYS_ERR == this->GetReactor()->UnRegisterIO(this, WRITE))
  {
    std::cerr << "UnRegisterIO failed" << std::endl;
    return SYS_ERR;
  }
 
  // Cancel all timers
  if(SYS_ERR == this->GetReactor()->CancelAllTimers(this))
  {
    std::cerr << "CancelAllTimers failed" << std::endl;
    return SYS_ERR;
  }
   
  // Close socket
  if(SYS_ERR == close(this->GetFd()))
  {
    perror("close");
    return SYS_ERR;
  }

  this->Destroy();

  return OK;
}


int FsRepoHandler::WriteFileToSocket()
{
  // Reading file to the application buffer if needed 
  if(!m_bufferOffset)
  {
    if(fseek(m_filesList, m_fileOffset, SEEK_SET))
    {
      perror("fseek");
      return SYS_ERR;
    } 
    
    int bytesRead = fread(m_buffer, sizeof(char), BUFFER_SIZE, m_filesList);
    m_currReadSize = bytesRead;
    
    if(bytesRead != BUFFER_SIZE)
    {
      if(feof(m_filesList))
      {
        m_isEof = true;
      }
      else if(ferror(m_filesList))
      {
        perror("fread");
        return SYS_ERR;
      }
    }
    
    m_fileOffset += bytesRead;
  }
  
  // Write bytes from application buffer to socket
  int bytesWritten = write(GetFd(), m_buffer + m_bufferOffset, m_currReadSize - m_bufferOffset);
  if(0 == bytesWritten || (SYS_ERR == bytesWritten && EAGAIN != errno && EWOULDBLOCK != errno))
  {
    return CONN_CLOSED_STATUS;
  }
  
  m_bufferOffset += bytesWritten;
  
  if(m_bufferOffset == m_currReadSize)
  {
    m_bufferOffset = 0;
    
    if(m_isEof)
    {
      // reset clientHandler 
      m_fileOffset = 0;
      m_isEof = false;
      
      return EOF_STATUS;
    } 
  }
  
  return OK;
}


} // namespace adv_cpp


